# AdventOfCode

My attempts at the AoC puzzles. I decided to do the Advent of Code 2024 puzzles in C++, the goal this year is to hopefully get as far as I can. If I truly wanted no limitations on myself from a language standpoint, I probably should've used something like python, but as always I want to have a bit of fun. So fair warning, terrible and probably not modern C++ code lies ahead.

# Reflections
I am actually decently proud of my progress. I was able to finish 22 days this year. I think if I were so inclined, I might be able to finish the last three days too but with my term starting soon, I don't have the motivation to do. I loved using C++! Creating all those custom data types and operator overloads with templates were so much fun! I was also ecstatic so solve some of the problems that I deemed were kind of hard. This is really good progress considering I've never done leetcode adjacent stuff before.

Another thing I am realizing is that, unless I specifically go into hyperoptimzation, python is pretty much on par with my C++ code in terms of speed. This was surprising because I was under the common misconception that python is much much (x1000) slower than C++. Good to know for the future

# Highlights

## Day 3 
Use of regex for this problem was fun. I've never used regex in programming before. 

## Day 4 
Creating a grid data type that automatically handles out of bound access without raising errors felt pretty good.

## Day 11 
I was so stoked to be able to solve part 2 here! I truly didn't think I would be able to. The first time I've used memoization too! (I am also super jealous that python users can directly use an in-built decorator for it)

## Day 14
I didn't like the part 2 here. It was too ambiguous what the creator wanted from us. I think I got lucky that my guess worked as a solution.

## Day 16
I have a tendency to always use recursion and dfs like approaches to solve problems. This problem forced me to use dijkstras and implement something akin to bfs to solve it. I was pretty happy with my solution to parts and the fact that I intuitively came up with an optimized version of the algorithm. (The optimization being that the first time you visit a spot, that itself is the shortest path to it).

## Day 17
I did a lot of manual work for Day 17 part 2, and my solution needs to be rewritten if the input changes. I wonder if I could've written a more general solver. Not complaining tho.

## Day 21 
This was the hardest problem that I solved in aoc this year. Super stoked to be able to solve this one as well. It was a pain to code up but I like that I had to use parts from Day 11 and Day 16 to solve part 2.
